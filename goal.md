# Implementation Plan for **gofft** (Go FFT Library)

This plan outlines a multi-phase approach to build an open-source FFT library in Go. It emphasizes a pure Go implementation (no cgo) for broad platform support (including WebAssembly), a focus on complex64 performance, and a clean API that hides backend details (like SIMD/assembly optimizations) from users. Each phase lists key tasks and goals, ensuring the library is extensible, well-tested, and contributor-friendly.

## Phase 1: MVP - Basic Radix-2 FFT (Complex64)

- **API Design (Plan-Based):** Define a core Plan type (e.g. gofft.Plan) with an idiomatic Go API similar to Gonum's Fourier package. Provide functions like NewPlan(n int) \*Plan to initialize for a fixed length, and methods Forward(dst, src \[\]complex64) and Inverse(dst, src \[\]complex64) (or Transform/Inverse) for computing the FFT and inverse. The Plan can store precomputed twiddle factors for reuse. This plan-based approach lets users set up an FFT once and reuse it, mirroring Gonum's pattern of NewFFT followed by transform calls[\[1\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=%2F%2F%20Initialize%20an%20FFT%20and,Coefficients%28nil%2C%20samples)[\[2\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=%2F%2F%20Initialize%20an%20FFT%20and,Coefficients%28nil%2C%20tone). Initially focus on complex64 as the primary type for efficiency; design the API such that complex128 support can be added later (e.g. via a separate Plan type or generics) without breaking changes.
- **Core Algorithm - Radix-2 Cooley-Tukey:** Implement an in-place Cooley-Tukey FFT for lengths that are powers of two. Start with a decimation-in-time or decimation-in-frequency algorithm using only pure Go code. Ensure the implementation is **in-place** (to avoid extra allocations) and operates on \[\]complex64. For the MVP, if an input length is not a power of 2, document the limitation or pad the input (possibly provide a helper like PadToPower2). This basic radix-2 FFT will serve as a foundation - it should produce correct results for power-of-two sizes (panicking or erroring for unsupported sizes, similar to Gonum's radix-2 functions which panic if length is not power of 2[\[3\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=If%20the%20length%20of%20seq,of%202%2C%20CoefficientsRadix2%20will%20panic)). Keep the implementation straightforward and readable, as this will be the baseline for future optimizations.
- **No cgo, Standard Toolchain:** All code in this phase is written in pure Go. Avoid any cgo or non-standard toolchain requirements. This ensures the library can be compiled to WebAssembly and run in web browsers with no changes. (Go's WebAssembly support can compile pure-Go packages out-of-the-box, whereas cgo or assembly targeted at specific architectures would not work under WASM.)
- **Testing (Correctness):** Set up a robust testing suite. Write unit tests for small FFTs where results can be manually verified. For example, test known sequences: delta functions (impulse), constant sequences, or simple sinusoids where the spectrum is known. Verify that Plan.Forward followed by Plan.Inverse returns the original sequence (within floating-point error). Include edge cases: length 1, smallest power of 2 (2, 4), and a moderate length (e.g. 256). Use the same Plan for multiple calls to ensure reusability works. Introduce **fuzzing** tests using Go's fuzzing support - generate random complex sequences and check that inverse( forward(x) ) â‰ˆ x (normalize if necessary), to catch any state bugs or precision issues. Also verify that no memory corruption or panics occur for random inputs. Aim for high code coverage (e.g. >90%) on the FFT logic in this phase, to build confidence in the core algorithm.
- **Benchmarking (Performance Baseline):** Create benchmark tests for the FFT on various lengths (e.g. 16, 256, 1024 points) using Go's testing.Benchmark. This establishes a baseline performance for pure-Go implementation. Although not optimized yet, these benchmarks will help gauge improvements in later phases. Document the performance (operations per second or throughput) of the MVP for reference.
- **Project Structure & Documentation:** Organize the code in a clean module structure. For example, use a single package gofft for the public API (Plan type and its methods, plus any user-facing functions). Implementation details can be in the same package for now (with unexported helper functions for butterflies, twiddle generation, etc.), or in an internal subpackage if preferred (e.g. gofft/internal/fftcore) to keep the API surface minimal. Add GoDoc comments to all exported types and functions so that usage is clear. Document that the current version supports power-of-two lengths and complex64 by default. This phase should conclude with a minimal, functioning library - easy to read and verify - setting the stage for further enhancements.

## Phase 2: Intermediate - Mixed Radix, Real FFT & Initial Optimizations

- **Support Arbitrary Lengths (Mixed Radix & Bluestein):** Extend the FFT algorithm to handle lengths other than powers of 2. Implement a **mixed-radix** FFT algorithm or a general Cooley-Tukey that factors the input length into small primes. For common small prime factors (3, 5, 7), consider implementing optimized radix-3, radix-5, etc., similar to approaches in other libraries. For lengths that include large prime factors or are prime, integrate **Bluestein's algorithm** as a fallback to maintain O(N log N) performance[\[4\]](https://pkg.go.dev/scientificgo.org/fft#:~:text=x%20is%20a%20power%20of,in%20that%20order). Bluestein's method rewrites a size-N DFT as a convolution that can be computed via FFT of a larger size[\[5\]](https://www.scribd.com/document/198689728/Bluestein-s-FFT-Algorithm#:~:text=Bluestein%27s%20FFT%20algorithm%20re,applications%20like%20interpolation%20and%20filtering) - incorporate this transparently so that users can FFT any length input. This may involve implementing zero-padding to the next efficient size (perhaps next power of 2 or highly composite length) and using the existing FFT on that. Ensure that the Plan creation (NewPlan(n)) now initializes the necessary twiddle factors or convolution kernels for arbitrary n. The API should remain the same; the plan internally decides whether to use direct Cooley-Tukey (for friendly sizes) or Bluestein (for awkward sizes) - all hidden from the user.
- **Real FFT Support:** Provide specialized support for real-input FFT to avoid redundant computation. Introduce a PlanReal (or integrate into the same Plan with a flag) to transform a \[\]float32 (real sequence) to its complex frequency spectrum. This real FFT should output only the non-redundant half-spectrum of complex results (size N/2+1 for input length N). This mirrors how Gonum's FFT type works for real sequences[\[6\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=,%C2%B6)[\[7\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=If%20the%20length%20of%20seq,Len%28%29%2F2%2B1%2C%20Coefficients%20will%20panic). Internally, implement real FFT by first computing a complex FFT of length N (perhaps by treating the real input as complex with zero imaginary parts) and then using symmetry to reduce output, or use a more optimized approach (e.g. split real FFT algorithm). Ensure the inverse transform for real FFT is also provided, producing real time-domain data from the half-spectrum. Add unit tests for real FFT specifically (e.g. sinusoids, impulse) to verify correctness and symmetry (the output should satisfy conjugate-even symmetry).
- **Optimize Critical Kernels (SIMD/Assembly - Step 1):** Begin introducing optimized code paths for performance-critical sections, while **encapsulating them behind the API**. Identify hotspots such as the inner loops of the butterfly operations. Write assembly implementations for **common sizes** (radix-2, radix-4 butterflies, etc.) for architectures like amd64 and arm64. For example, implement an AVX2-optimized butterfly that processes 4 or 8 complex64 values at once using SIMD registers. _Important:_ Keep these details invisible to library users:
- Place assembly in files with architecture-specific suffix (e.g. fft_amd64.s, fft_arm64.s) or use Go build tags to include them only on supported platforms.
- Maintain the same function signature as the Go version so that the optimizer picks it up (Go will link the assembly version if it exists). Alternatively, use an internal dispatch mechanism as described below.
- For instance, provide an assembly function for a length-8 FFT using AVX, and call it for those cases internally.

Introduce a **backend dispatch mechanism**: at package init or Plan initialization, detect available CPU features and choose the optimal implementation. Go's runtime/internal/cpu package or third-party cpuid packages can check for AVX, AVX2, NEON, etc. Set internal flags or function pointers accordingly. For example, on amd64, use AVX2 if available, else SSE2, else fall back to pure Go. The Plan methods would then call a function that dynamically dispatches to the correct kernel. This pattern is used in Go's standard library (e.g., crypto libraries): a global useAVX2 flag set in init() can gate which routine is called[\[8\]](https://cryptologie.net/posts/simd-instructions-in-go/#:~:text=func%20hashBlocks%28h%20,h%2C%20c%2C%20flag%2C%20blocks). By the end of this phase, the library will still expose the same API (Plan.Forward, etc.) but internally might do if hasSIMD { asmFFT(data) } else { goFFT(data) }. All SIMD/asm details remain hidden behind unexported symbols and files, preserving the clean API.

- **Extended Testing & Fuzzing:** With the increased algorithmic complexity, expand the test suite. Add tests for non-power-of-two lengths (e.g. length 6, 10, prime lengths like 7, 13) to ensure the mixed-radix/Bluestein logic produces correct results. Cross-verify a few cases with a naive DFT implementation for small sizes to ensure correctness. Test that real FFT forward followed by inverse returns the original real sequence. Continue fuzzing for various lengths (especially around prime or large prime factor lengths) - this can catch corner cases in Bluestein or mixed-radix implementations. Include random real input tests as well. Ensure that tests cover both code paths: with and without assembly (you can use build tags or runtime flags to force pure-Go mode in tests to verify both). By now, the test coverage should remain high despite more code - aim to cover all new branches (Bluestein path, real FFT path, etc.).
- **Benchmarking Improvements:** Re-run benchmarks on the same sizes as Phase 1 to measure speedups from optimizations. You should see improvements for sizes where the assembly is used or where mixed-radix avoids slowdown. Also benchmark new capabilities: e.g. compare performance of real FFT vs equivalent complex FFT of same length (real should be ~2x faster ideally). Profile the library (using go test -bench and go tool pprof) to identify any remaining bottlenecks. This will guide further low-level optimization in the next phase.
- **Module Layout & Docs Update:** As the codebase grows, ensure the project structure remains clear. Possibly refactor into sub-packages:
- Keep user-facing API in package gofft.
- Move complex algorithm implementations into gofft/internal (like internal/fft for general FFT, internal/fft/asm for assembly kernels, etc.) so they can be tested and developed without exposing internals. For example, the Bluestein convolution helper might live in internal/fft/bluestein.go, small prime factor routines in radix3.go, radix5.go, etc., akin to the structure of Scientific Go's FFT package[\[9\]](https://pkg.go.dev/scientificgo.org/fft#:~:text=View%20all%20Source%20files).
- The "kernel selection" (SIMD dispatch) logic can reside in a single file (e.g. dispatch.go) that uses init() to set up flags or function pointers, as described above. Clearly comment this section to guide contributors on how the library picks implementations for different architectures.

Update documentation to reflect new features: note that arbitrary lengths are supported (mention internally Bluestein is used for primes, without delving into math details in user docs), and describe how to use the real-input FFT API. Encourage feedback or contributions, e.g. in the README, mention which parts are optimized in assembly and that contributions for other architectures are welcome.

## Phase 3: Advanced - N-D FFT, Batch Processing, Full Optimization

- **N-Dimensional FFT:** Extend the library to support multi-dimensional transforms (2D, 3D, etc.), which are important for image processing, volumetric data, etc. Implement this by **plan composition** - for example, a 2D FFT of an MxN matrix can be done by performing M independent N-point FFTs on rows, then N independent M-point FFTs on columns[\[10\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=%2F%2F%20Make%20appropriately%20sized%20real,NewCmplxFFT%28r)[\[11\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=rows%20%3A%3D%20make%28%5B%5Dcomplex128%2C%20r,i%2B1%29%5D%2C%20image.RawRowView%28i%29%29) (using plans for each dimension). Provide a user-friendly API, such as func FFT2D(dst, src \*MatrixComplex64, inverse bool) or allow the Plan to be generalized to multiple dimensions (e.g. a Plan could hold dimension sizes and multiple sets of twiddles). A straightforward approach is to reuse the 1D Plan: perform 1D transforms along one axis, transpose, then along the other axis, etc. Ensure the API makes it easy to transform real 2D data as well (maybe via a convenience wrapper that handles real-to-complex conversion if needed). Testing: add tests for 2D FFT using small matrices (verify against brute force or properties like known patterns). If performance is a concern, consider writing specialized 2D routines later, but initially focus on correctness and reusing the robust 1D implementation.
- **Batch & Strided FFTs:** Add support for performing FFT on multiple datasets in one call, and for strided data. _Batch FFT_ means if users have many signals of the same length, they can transform them in a single function call (internally this could just loop, but later could be optimized or parallelized). Provide an API like plan.TransformBatch(dst, src \[\]complex64, count int, strideSrc int, strideDst int) where count is number of signals and stride allows each signal to be located at an offset in the slice (or alternatively, accept a slice of slices). _Strided FFT_ is useful for transforming data that's not contiguous (for example, a column of a matrix which is a stride in memory). The Plan can incorporate logic to handle stride by copying to a contiguous temp buffer, or by computing in-place if the stride is 1. These features enhance the library's flexibility for advanced use cases (and mirror capabilities of libraries like FFTW and cuFFT). Test with simple cases (e.g. 2 signals of length 8 interleaved in an array) to ensure batch/stride logic works. Also test that batch FFT results match doing each FFT individually.
- **Enhanced Performance Optimizations:** In this phase, maximize performance across platforms:
- Complete the set of **SIMD kernels** for common FFT sizes. Implement assembly for more FFT stages (radix-2,4,8, possibly 16), and for both forward and inverse transforms. Ensure that both complex64 and complex128 variants (if supported) have optimized paths (complex128 might benefit from using 256-bit registers to process one complex128 at a time, whereas complex64 can use 256-bit to do two at once, etc.). Include ARM NEON assembly for arm64 platforms for parity. Each assembly routine should have a corresponding pure Go backup for portability.
- Refine the **CPU feature dispatch** introduced earlier. If not already done, use Go's internal/cpu or a similar mechanism to detect features like AVX2, AVX-512, Neon, and even WASM SIMD in the future. Based on this, choose the highest available optimization. This could be done via function pointers (e.g. var butterflyFunc func(\[\]complex64) = butterflyGeneric, set in init). The Blake2 hash example in Go's crypto library demonstrates this runtime dispatch approach[\[8\]](https://cryptologie.net/posts/simd-instructions-in-go/#:~:text=func%20hashBlocks%28h%20,h%2C%20c%2C%20flag%2C%20blocks) - apply the same idea so that once at startup the fastest available routine is selected, avoiding branches inside the inner loops. Document in the code which instruction sets are utilized and fallbacks, so future contributors can extend (e.g. adding AVX-512 support when Go supports it).
- Investigate **parallelization** for very large FFTs or batched FFTs. Although Go can manage concurrency outside the library, we might offer an option to use goroutines internally for huge transforms (splitting the recursion or iterating batches in parallel). If implemented, hide it behind an option or automatically use multiple cores when beneficial (ensure thread-safety of Plan if doing this). This is an optional stretch goal if performance scaling is needed.
- **Robust Testing & Fuzzing:** By now, the library is complex; maintain rigorous testing. Add high-level property tests: e.g., for random data, verify energy is preserved (Parseval's theorem) within tolerance, or that known identities (like FFT of a delta is flat spectrum) hold. Continue fuzzing with larger sizes and multi-dimensional cases. Test across different architectures if possible (CI can run tests on amd64 and arm64 to ensure assembly and generic paths both produce identical results). Aim for **comprehensive test coverage** of all features - every code path (Bluestein, each radix, each SIMD path) should run in some test. Add long-run randomized tests to be safe (maybe under a build tag for extensive testing).
- **Benchmark & Profile:** Benchmark all new features: multi-dimensional FFT performance (e.g. 2D 256x256 image), batch FFT throughput vs single-call loops, etc. Compare performance of complex64 vs complex128 if supported. Keep an eye on GC pressure - ensure minimal allocations per transform (the Plan should reuse buffers and only allocate at init). Profiling should show the bulk of time in the optimized kernels. If not, identify any remaining overhead (maybe bounds checks or suboptimal memory access) and address them (e.g., use //go:nosplit or unsafe pointers carefully if needed, while still maintaining safety where possible).
- **Finalize Documentation & Contribution Guidelines:** At this advanced stage, refine documentation for end-users and contributors:
- Write detailed GoDoc comments for multi-dimensional and batch APIs, with examples.
- Update the README with usage examples for 1D, 2D, real vs complex, etc., so users can quickly adopt the library.
- Outline the architecture in contributor docs: explain how the Plan is structured, how new hardware optimizations can be added (e.g. "to add a new SIMD kernel, implement it in internal/fft/yourasm.s and add a dispatch in dispatch.go"), and how the test/benchmark structure is organized.
- Emphasize the clean API stability: by now, users should not need to know about any internal changes. All improvements are under the hood. Commit to semantic versioning so that future changes that affect the API are done in a controlled manner.
- Encourage contributions for new features (e.g., "future ideas" like adding a convolution API using FFT, or exploring GPU acceleration via Vulkan/Metal compute in Go, etc., though those are beyond initial scope).

By following this phased plan, **gofft** will evolve from a simple FFT implementation into a robust, high-performance library. Each phase builds on the last: ensuring correctness first, then broadening functionality (mixed radix, real FFT), and finally achieving state-of-the-art performance with assembly optimizations and advanced features. Throughout, the public API remains clean and idiomatic, hiding complexity (SIMD, Bluestein, etc.) behind the scenes. The result will be a **pure Go FFT library** that is easy to use, extensible for the future, well-tested, and ready for community contributions - from adding new optimized kernels to supporting new transform types - all while maintaining a stable and user-friendly interface.

**Sources:**

- Gonum DSP Fourier Package - example of plan-based API (NewFFT, Coefficients, etc.) and multi-dimensional usage[\[1\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=%2F%2F%20Initialize%20an%20FFT%20and,Coefficients%28nil%2C%20samples)[\[10\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=%2F%2F%20Make%20appropriately%20sized%20real,NewCmplxFFT%28r).
- ScientificGo FFT - strategy for arbitrary-length FFT using Bluestein's algorithm for prime lengths[\[4\]](https://pkg.go.dev/scientificgo.org/fft#:~:text=x%20is%20a%20power%20of,in%20that%20order).
- David Wong, _SIMD instructions in Go_ - illustrates runtime CPU feature detection and function dispatch for assembly optimizations[\[8\]](https://cryptologie.net/posts/simd-instructions-in-go/#:~:text=func%20hashBlocks%28h%20,h%2C%20c%2C%20flag%2C%20blocks).

[\[1\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=%2F%2F%20Initialize%20an%20FFT%20and,Coefficients%28nil%2C%20samples) [\[2\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=%2F%2F%20Initialize%20an%20FFT%20and,Coefficients%28nil%2C%20tone) [\[3\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=If%20the%20length%20of%20seq,of%202%2C%20CoefficientsRadix2%20will%20panic) [\[6\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=,%C2%B6) [\[7\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=If%20the%20length%20of%20seq,Len%28%29%2F2%2B1%2C%20Coefficients%20will%20panic) [\[10\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=%2F%2F%20Make%20appropriately%20sized%20real,NewCmplxFFT%28r) [\[11\]](https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier#:~:text=rows%20%3A%3D%20make%28%5B%5Dcomplex128%2C%20r,i%2B1%29%5D%2C%20image.RawRowView%28i%29%29) fourier package - gonum.org/v1/gonum/dsp/fourier - Go Packages

<https://pkg.go.dev/gonum.org/v1/gonum/dsp/fourier>

[\[4\]](https://pkg.go.dev/scientificgo.org/fft#:~:text=x%20is%20a%20power%20of,in%20that%20order) [\[9\]](https://pkg.go.dev/scientificgo.org/fft#:~:text=View%20all%20Source%20files) fft package - scientificgo.org/fft - Go Packages

<https://pkg.go.dev/scientificgo.org/fft>

[\[5\]](https://www.scribd.com/document/198689728/Bluestein-s-FFT-Algorithm#:~:text=Bluestein%27s%20FFT%20algorithm%20re,applications%20like%20interpolation%20and%20filtering) Bluestein's FFT Algorithm Explained | PDF | Fast Fourier Transform | Fourier Analysis

<https://www.scribd.com/document/198689728/Bluestein-s-FFT-Algorithm>

[\[8\]](https://cryptologie.net/posts/simd-instructions-in-go/#:~:text=func%20hashBlocks%28h%20,h%2C%20c%2C%20flag%2C%20blocks) SIMD instructions in Go - cryptologie.net

<https://cryptologie.net/posts/simd-instructions-in-go/>
